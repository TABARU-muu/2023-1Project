{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "view-in-github",
        "colab_type": "text"
      },
      "source": [
        "<a href=\"https://colab.research.google.com/github/TABARU-muu/2023-1Project/blob/main/%EC%B6%94%EC%B2%9C_%EC%8B%9C%EC%8A%A4%ED%85%9C\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "oIAnNuuX2EOr"
      },
      "source": [
        "# 추천 시스템 (Recommender Systems)\n",
        "\n",
        "* 추천 시스템은 크게 두가지로 구분 가능\n",
        "  * 컨텐츠 기반 필터링 (content-based filtering)\n",
        "  * 협업 필터링 (collaborative filtering)\n",
        "* 두가지를 조합한 hybrid 방식도 가능\n",
        "* 컨텐츠 기반 필터링은 지금까지 사용자의 이전 행동과 명시적 피드백을 통해 사용자가 좋아하는 것과 유사한 항목을 추천\n",
        "* 협업 필터링은 사용자와 항목간의 유사성을 동시에 사용해 추천"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "pKQvtsfX2bRf"
      },
      "source": [
        "## Surprise\n",
        "\n",
        "* 추천 시스템 개발을 위한 라이브러리\n",
        "* 다양한 모델과 데이터 제공\n",
        "* scikit-learn과 유사한 사용 방법"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 1,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "M_ONZZVewvtI",
        "outputId": "65d997bd-9a32-42d9-fe5f-bda626f3fe89"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Looking in indexes: https://pypi.org/simple, https://us-python.pkg.dev/colab-wheels/public/simple/\n",
            "Collecting scikit-surprise\n",
            "  Downloading scikit-surprise-1.1.3.tar.gz (771 kB)\n",
            "\u001b[2K     \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m772.0/772.0 kB\u001b[0m \u001b[31m10.3 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
            "\u001b[?25h  Preparing metadata (setup.py) ... \u001b[?25l\u001b[?25hdone\n",
            "Requirement already satisfied: joblib>=1.0.0 in /usr/local/lib/python3.9/dist-packages (from scikit-surprise) (1.2.0)\n",
            "Requirement already satisfied: numpy>=1.17.3 in /usr/local/lib/python3.9/dist-packages (from scikit-surprise) (1.22.4)\n",
            "Requirement already satisfied: scipy>=1.3.2 in /usr/local/lib/python3.9/dist-packages (from scikit-surprise) (1.10.1)\n",
            "Building wheels for collected packages: scikit-surprise\n",
            "  Building wheel for scikit-surprise (setup.py) ... \u001b[?25l\u001b[?25hdone\n",
            "  Created wheel for scikit-surprise: filename=scikit_surprise-1.1.3-cp39-cp39-linux_x86_64.whl size=3195795 sha256=a760b4d4a7c00b537e586db2ea8fa37d61ee36b2e5463c55a119b46ff81b5fb8\n",
            "  Stored in directory: /root/.cache/pip/wheels/c6/3a/46/9b17b3512bdf283c6cb84f59929cdd5199d4e754d596d22784\n",
            "Successfully built scikit-surprise\n",
            "Installing collected packages: scikit-surprise\n",
            "Successfully installed scikit-surprise-1.1.3\n"
          ]
        }
      ],
      "source": [
        "!pip install scikit-surprise"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "f8S2mbY13TPl"
      },
      "source": [
        "간단한 surprise 실습"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 2,
      "metadata": {
        "id": "FXrDk0XH2vbx"
      },
      "outputs": [],
      "source": [
        "from surprise import SVD\n",
        "from surprise import Dataset\n",
        "from surprise.model_selection import cross_validate"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 3,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "M0SJB24k3ReQ",
        "outputId": "09c5f418-3c8b-4f9c-fecb-8703d65cd9b0"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Trying to download dataset from https://files.grouplens.org/datasets/movielens/ml-100k.zip...\n",
            "Done! Dataset ml-100k has been saved to /root/.surprise_data/ml-100k\n"
          ]
        },
        {
          "output_type": "execute_result",
          "data": {
            "text/plain": [
              "[('196', '242', 3.0, '881250949'),\n",
              " ('186', '302', 3.0, '891717742'),\n",
              " ('22', '377', 1.0, '878887116'),\n",
              " ('244', '51', 2.0, '880606923'),\n",
              " ('166', '346', 1.0, '886397596'),\n",
              " ('298', '474', 4.0, '884182806'),\n",
              " ('115', '265', 2.0, '881171488'),\n",
              " ('253', '465', 5.0, '891628467'),\n",
              " ('305', '451', 3.0, '886324817'),\n",
              " ('6', '86', 3.0, '883603013')]"
            ]
          },
          "metadata": {},
          "execution_count": 3
        }
      ],
      "source": [
        "data = Dataset.load_builtin('ml-100k',prompt=False)\n",
        "data.raw_ratings[:10]"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 4,
      "metadata": {
        "id": "IGZjsosZ3jwy"
      },
      "outputs": [],
      "source": [
        "model = SVD()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 5,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "nAF9VVHt9qz9",
        "outputId": "1acac530-744e-4169-934a-03a80695a630"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Evaluating RMSE, MAE of algorithm SVD on 5 split(s).\n",
            "\n",
            "                  Fold 1  Fold 2  Fold 3  Fold 4  Fold 5  Mean    Std     \n",
            "RMSE (testset)    0.9286  0.9367  0.9429  0.9387  0.9395  0.9373  0.0048  \n",
            "MAE (testset)     0.7319  0.7368  0.7404  0.7399  0.7436  0.7385  0.0039  \n",
            "Fit time          1.07    1.08    0.97    1.28    3.46    1.57    0.95    \n",
            "Test time         0.13    0.26    0.14    0.27    0.38    0.23    0.09    \n"
          ]
        },
        {
          "output_type": "execute_result",
          "data": {
            "text/plain": [
              "{'test_rmse': array([0.92855237, 0.93665352, 0.9429388 , 0.93870139, 0.93945089]),\n",
              " 'test_mae': array([0.7319423 , 0.73680457, 0.74037602, 0.73985724, 0.7435686 ]),\n",
              " 'fit_time': (1.0744328498840332,\n",
              "  1.0799548625946045,\n",
              "  0.9703645706176758,\n",
              "  1.2757759094238281,\n",
              "  3.4596521854400635),\n",
              " 'test_time': (0.12734079360961914,\n",
              "  0.2617342472076416,\n",
              "  0.1363677978515625,\n",
              "  0.26662492752075195,\n",
              "  0.3764817714691162)}"
            ]
          },
          "metadata": {},
          "execution_count": 5
        }
      ],
      "source": [
        "cross_validate(model,data,measures=['rmse','mae'],cv=5,verbose=True)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "tP5L65zvCRlv"
      },
      "source": [
        "## 컨텐츠 기반 필터링 (Content-based Filtering)\n",
        "\n",
        "* 컨텐츠 기반 필터링은 이전의 행동과 명시적 피드백을 통해 좋아하는 것과 유사한 항목을 추천\n",
        "  * ex) 내가 지금 까지 시청한 영화 목록과 다른 사용자의 시청 목록을 비교해 나와 비슷한 취향의 사용자가 시청한 영화를 추천\n",
        "* 유사도를 기반으로 추천\n",
        "* 컨텐츠 기반 필터링은 다음과 같은 장단점이 있다.\n",
        "  * 장점\n",
        "    * 많은 수의 사용자를 대상으로 쉽게 확장 가능\n",
        "    * 사용자가 관심을 갖지 않던 상품 추천 가능\n",
        "  * 단점\n",
        "    * 입력 특성을 직접 설계해야 하기 때문에 많은 도메인 지식이 필요\n",
        "    * 사용자의 기존 관심사항을 기반으로만 추천 가능"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 6,
      "metadata": {
        "id": "M81hRKa9-9pK"
      },
      "outputs": [],
      "source": [
        "import numpy as np\n",
        "from surprise import Dataset"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "0NyTt1u8LLCP"
      },
      "source": [
        "* 이진 벡터의 내적을 통해 다른 사용자들과의 유사도 구하기\n",
        "* 나와 가장 높은 유사도를 가진 사용자의 시청 목록을 추천"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 7,
      "metadata": {
        "id": "-Y3Y_rNWH-zT"
      },
      "outputs": [],
      "source": [
        "data = Dataset.load_builtin('ml-100k',prompt=False)\n",
        "raw_data = np.array(data.raw_ratings, dtype=int)"
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "raw_data[:, 0] -= 1\n",
        "raw_data[:, 1] -= 1"
      ],
      "metadata": {
        "id": "cGKXizmn11fi"
      },
      "execution_count": 8,
      "outputs": []
    },
    {
      "cell_type": "code",
      "execution_count": 9,
      "metadata": {
        "id": "z60YDlPOJzSr",
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "outputId": "3137d9d7-874e-4973-f975-cdb3f62f44fc"
      },
      "outputs": [
        {
          "output_type": "execute_result",
          "data": {
            "text/plain": [
              "(943, 1682)"
            ]
          },
          "metadata": {},
          "execution_count": 9
        }
      ],
      "source": [
        "n_users = np.max(raw_data[:,0])\n",
        "n_movies = np.max(raw_data[:,1])\n",
        "shape = (n_users + 1,n_movies + 1)\n",
        "shape"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 10,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "4f20U_BFIbQA",
        "outputId": "1dd40f06-92e0-4cef-e824-af5a1759a375"
      },
      "outputs": [
        {
          "output_type": "execute_result",
          "data": {
            "text/plain": [
              "array([[1, 1, 1, ..., 0, 0, 0],\n",
              "       [1, 0, 0, ..., 0, 0, 0],\n",
              "       [0, 0, 0, ..., 0, 0, 0],\n",
              "       ...,\n",
              "       [1, 0, 0, ..., 0, 0, 0],\n",
              "       [0, 0, 0, ..., 0, 0, 0],\n",
              "       [0, 1, 0, ..., 0, 0, 0]])"
            ]
          },
          "metadata": {},
          "execution_count": 10
        }
      ],
      "source": [
        "adj_matrix = np.ndarray(shape,dtype=int)\n",
        "for user_id, movie_id,ratingg,time in raw_data:\n",
        "  adj_matrix[user_id][movie_id] = 1.\n",
        "adj_matrix"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 11,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "JT6HXk_8I4Zd",
        "outputId": "054785da-6f50-4c0b-ba27-c6ed6658369b"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Bset Match: 183, Best Match ID:275\n"
          ]
        }
      ],
      "source": [
        "my_id, my_vector = 0, adj_matrix[0]\n",
        "best_match, best_match_id, best_match_vector = -1,-1,[]\n",
        "\n",
        "for user_id, user_vector in enumerate(adj_matrix):\n",
        "  if my_id !=user_id:\n",
        "    similarity = np.dot(my_vector,user_vector)\n",
        "    if similarity > best_match:\n",
        "      best_match = similarity\n",
        "      best_match_id = user_id\n",
        "      best_match_vector = user_vector\n",
        "\n",
        "\n",
        "print('Bset Match: {}, Best Match ID:{}'.format(best_match,best_match_id))"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 12,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "mRr8UnD7MB7U",
        "outputId": "d8ddb87e-dee6-4367-c9d3-bf52a10d5615"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "[272, 273, 275, 280, 281, 283, 287, 288, 289, 290, 292, 293, 297, 299, 300, 301, 302, 306, 312, 314, 315, 316, 317, 321, 322, 323, 324, 327, 330, 331, 332, 333, 339, 342, 345, 346, 353, 354, 355, 356, 357, 363, 364, 365, 366, 372, 374, 378, 379, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 394, 395, 396, 398, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 412, 414, 416, 417, 418, 419, 420, 422, 424, 425, 426, 427, 428, 430, 431, 432, 435, 442, 446, 447, 448, 449, 450, 451, 452, 454, 455, 457, 460, 461, 462, 468, 469, 470, 471, 472, 473, 474, 478, 495, 500, 507, 517, 522, 525, 530, 539, 540, 543, 545, 546, 548, 549, 550, 551, 553, 557, 558, 560, 561, 562, 563, 565, 566, 567, 568, 570, 571, 574, 575, 576, 577, 580, 581, 582, 585, 587, 589, 590, 594, 596, 602, 623, 626, 627, 630, 633, 635, 639, 646, 648, 651, 652, 654, 657, 664, 668, 671, 677, 678, 681, 683, 684, 685, 690, 691, 692, 695, 696, 708, 709, 714, 718, 719, 720, 724, 726, 727, 731, 733, 734, 736, 738, 741, 742, 745, 746, 747, 749, 750, 754, 758, 762, 764, 767, 768, 769, 770, 771, 772, 773, 778, 779, 782, 785, 788, 789, 793, 795, 796, 799, 800, 801, 802, 805, 806, 808, 815, 819, 822, 824, 830, 839, 842, 843, 844, 852, 853, 870, 875, 878, 880, 889, 901, 914, 915, 918, 921, 927, 929, 930, 938, 940, 941, 942, 948, 950, 958, 968, 973, 974, 976, 992, 999, 1005, 1009, 1010, 1012, 1015, 1018, 1027, 1030, 1034, 1035, 1041, 1043, 1045, 1046, 1051, 1055, 1072, 1073, 1078, 1080, 1082, 1088, 1089, 1090, 1094, 1097, 1108, 1109, 1117, 1128, 1130, 1134, 1139, 1140, 1144, 1156, 1169, 1171, 1179, 1193, 1198, 1207, 1209, 1212, 1217, 1219, 1220, 1227, 1231, 1238, 1239, 1243, 1244, 1252, 1266, 1272, 1273, 1300, 1313, 1406, 1412, 1415, 1470, 1477, 1480, 1481, 1482]\n"
          ]
        }
      ],
      "source": [
        "recommend_list=[]\n",
        "for i, log in enumerate(zip(my_vector, best_match_vector)):\n",
        "  log1,log2 = log\n",
        "  if log1 < 1.and log2 > 0.:\n",
        "    recommend_list.append(i)\n",
        "print(recommend_list)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "zR7-LITWZQnJ"
      },
      "source": [
        "* 유클리드 거리를 사용해 추천\n",
        "$$euclidean = \\sqrt{\\sum_{d=1}^{D}(A_i - B_i)^2}$$\n",
        "* 거리가 가까울 수록(값이 작을 수록) 나와 유사한 사용자"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 13,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "WhbLJGz3NuNA",
        "outputId": "4b50e1c3-f1e4-47a0-8b32-520746b44c98"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Bset Match: 14.832396974191326, Best Match ID:737\n"
          ]
        }
      ],
      "source": [
        "my_id, my_vector = 0, adj_matrix[0]\n",
        "best_match, best_match_id, best_match_vector = 9999,-1,[]\n",
        "\n",
        "for user_id, user_vector in enumerate(adj_matrix):\n",
        "  if my_id !=user_id:\n",
        "    euclidean_dist = np.sqrt(np.sum(np.square(my_vector - user_vector)))\n",
        "    if euclidean_dist < best_match:\n",
        "      best_match = euclidean_dist\n",
        "      best_match_id = user_id\n",
        "      best_match_vector = user_vector\n",
        "\n",
        "\n",
        "print('Bset Match: {}, Best Match ID:{}'.format(best_match,best_match_id))"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 14,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "xbS037xebA76",
        "outputId": "670097b1-87d1-42ec-e6cd-c09c1e62906c"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "[297, 312, 317, 342, 356, 366, 379, 384, 392, 402, 404, 407, 417, 422, 428, 433, 448, 454, 469, 473, 495, 510, 516, 526, 527, 549, 567, 602, 635, 649, 650, 654, 658, 661, 664, 696, 731, 746, 750, 754, 915, 918, 925, 929, 950, 968, 1015, 1046]\n"
          ]
        }
      ],
      "source": [
        "recommend_list=[]\n",
        "for i, log in enumerate(zip(my_vector, best_match_vector)):\n",
        "  log1,log2 = log\n",
        "  if log1 < 1.and log2 > 0.:\n",
        "    recommend_list.append(i)\n",
        "print(recommend_list)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "52c6nfonct7x"
      },
      "source": [
        "* 코사인 유사도를 사용해 추천\n",
        "\n",
        "\\begin{equation}\n",
        "cos \\theta = \\frac{A \\cdot B}{||A|| \\times ||B||}\n",
        "\\end{equation}\n",
        "* 두 벡터가 이루고 있는 각을 계산"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 15,
      "metadata": {
        "id": "WEJMnmAYejJW"
      },
      "outputs": [],
      "source": [
        "def compute_cos_similarity(v1,v2):\n",
        "  norm1 = np.sqrt(np.sum(np.square(v1)))\n",
        "  norm2 = np.sqrt(np.sum(np.square(v2)))\n",
        "  dot = np.dot(v1,v2)\n",
        "  return dot /(norm1*norm2)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 16,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "eouFYlVZb3iT",
        "outputId": "6d5484fa-fcd2-4e90-e178-7827d947ce21"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Bset Match: 0.5278586163659506, Best Match ID:915\n"
          ]
        }
      ],
      "source": [
        "my_id, my_vector = 0, adj_matrix[0]\n",
        "best_match, best_match_id, best_match_vector = -1,-1,[]\n",
        "\n",
        "for user_id, user_vector in enumerate(adj_matrix):\n",
        "  if my_id !=user_id:\n",
        "    cos_similarity = compute_cos_similarity(my_vector, user_vector)\n",
        "    if cos_similarity > best_match:\n",
        "      best_match = cos_similarity\n",
        "      best_match_id = user_id\n",
        "      best_match_vector = user_vector\n",
        "\n",
        "\n",
        "print('Bset Match: {}, Best Match ID:{}'.format(best_match,best_match_id))"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 17,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "HVhjBMure_4D",
        "outputId": "53190846-f25e-4928-b5fe-da4ef4586849"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "[272, 275, 279, 280, 283, 285, 289, 294, 297, 316, 317, 355, 365, 366, 368, 379, 380, 381, 384, 386, 392, 398, 401, 404, 416, 420, 422, 424, 426, 427, 430, 432, 450, 460, 461, 466, 469, 471, 473, 474, 475, 479, 482, 483, 497, 505, 508, 510, 511, 522, 526, 527, 529, 530, 534, 536, 540, 545, 548, 549, 556, 557, 558, 560, 565, 567, 568, 569, 577, 580, 581, 582, 592, 596, 630, 635, 639, 641, 649, 651, 654, 673, 677, 678, 683, 684, 692, 696, 701, 703, 707, 708, 709, 712, 714, 719, 720, 726, 731, 734, 736, 738, 740, 745, 747, 754, 755, 761, 762, 763, 766, 780, 789, 791, 805, 819, 823, 824, 830, 843, 862, 865, 918, 929, 930, 938, 942, 943, 947, 958, 959, 960, 970, 977, 1004, 1008, 1009, 1010, 1013, 1041, 1045, 1069, 1072, 1073, 1078, 1097, 1100, 1108, 1112, 1118, 1134, 1193, 1205, 1207, 1216, 1219, 1267, 1334, 1400, 1427, 1596, 1681]\n"
          ]
        }
      ],
      "source": [
        "recommend_list=[]\n",
        "for i, log in enumerate(zip(my_vector, best_match_vector)):\n",
        "  log1,log2 = log\n",
        "  if log1 < 1. and log2 > 0.:\n",
        "    recommend_list.append(i)\n",
        "print(recommend_list)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "0dbZPgC4gZYw"
      },
      "source": [
        "기존 방법에 명시적 피드백(사용자가 평가한 영화 점수)을 추가해 실험"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 18,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "_5udkr1PfGAD",
        "outputId": "a8798a4f-34af-4a03-e574-1dad1ed2d8ab"
      },
      "outputs": [
        {
          "output_type": "execute_result",
          "data": {
            "text/plain": [
              "array([[5, 3, 4, ..., 0, 0, 0],\n",
              "       [4, 0, 0, ..., 0, 0, 0],\n",
              "       [0, 0, 0, ..., 0, 0, 0],\n",
              "       ...,\n",
              "       [5, 0, 0, ..., 0, 0, 0],\n",
              "       [0, 0, 0, ..., 0, 0, 0],\n",
              "       [0, 5, 0, ..., 0, 0, 0]])"
            ]
          },
          "metadata": {},
          "execution_count": 18
        }
      ],
      "source": [
        "adj_matrix=np.ndarray(shape, dtype=int)\n",
        "for user_id,movie_id,rating,time in raw_data:\n",
        "  adj_matrix[user_id][movie_id]=rating\n",
        "adj_matrix\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 19,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "ApfZVTtGgs41",
        "outputId": "714d8d89-96b8-4e96-b6f5-758ac51c84af"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Bset Match: 55.06359959174482, Best Match ID:737\n"
          ]
        }
      ],
      "source": [
        "my_id, my_vector = 0, adj_matrix[0]\n",
        "best_match, best_match_id, best_match_vector = 9999,-1,[]\n",
        "\n",
        "for user_id, user_vector in enumerate(adj_matrix):\n",
        "  if my_id !=user_id:\n",
        "    euclidean_dist = np.sqrt(np.sum(np.square(my_vector - user_vector)))\n",
        "    if euclidean_dist < best_match:\n",
        "      best_match = euclidean_dist\n",
        "      best_match_id = user_id\n",
        "      best_match_vector = user_vector\n",
        "\n",
        "\n",
        "print('Bset Match: {}, Best Match ID:{}'.format(best_match,best_match_id))\n",
        "\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 20,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "OYTI1nT0hKtz",
        "outputId": "333762ed-5ebe-475d-a983-a7ca4db3a3a3"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Bset Match: 0.569065731527988, Best Match ID:915\n"
          ]
        }
      ],
      "source": [
        "my_id, my_vector = 0, adj_matrix[0]\n",
        "best_match, best_match_id, best_match_vector = -1,-1,[]\n",
        "\n",
        "for user_id, user_vector in enumerate(adj_matrix):\n",
        "  if my_id !=user_id:\n",
        "    cos_similarity = compute_cos_similarity(my_vector, user_vector)\n",
        "    if cos_similarity > best_match:\n",
        "      best_match = cos_similarity\n",
        "      best_match_id = user_id\n",
        "      best_match_vector = user_vector\n",
        "\n",
        "\n",
        "print('Bset Match: {}, Best Match ID:{}'.format(best_match,best_match_id))"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "HreRrslahd32"
      },
      "source": [
        "## 협업 필터링(Collaborative Filtering)\n",
        "\n",
        "* 사용자와 항목의 유사성을 동시에 고려해 추천\n",
        "* 기존에 내 관심사가 아닌 항목이라도 추천 가능\n",
        "* 자동으로 임베딩 학습 가능\n",
        "* 협업 필터링은 다음과 같은 장단점을 갖고 있다.\n",
        "  * 장점\n",
        "    * 자동으로 임베딩을 학습하기 때문에 도메인 지식이 필요 없다.\n",
        "    * 기존의 관심사가 아니더라도 추천 가능\n",
        "  * 단점\n",
        "    * 학습 과정에 나오지 않은 항목은 임베딩을 만들 수 없음\n",
        "    * 추가 특성을 사용하기 어려움"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 21,
      "metadata": {
        "id": "BSj5Ex6yhPxq"
      },
      "outputs": [],
      "source": [
        "from surprise import KNNBasic, SVDpp,NMF\n",
        "from surprise import Dataset\n",
        "from surprise.model_selection import cross_validate"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 22,
      "metadata": {
        "id": "mWAiO62WkH2U"
      },
      "outputs": [],
      "source": [
        "data = Dataset.load_builtin('ml-100k', prompt=False)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "LKP-UxZkkc8n"
      },
      "source": [
        "* KNN을 사용한 협업 필터링"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 23,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "x9LlEDqvkayg",
        "outputId": "ec8d4d17-3fb3-4ddd-d11e-44f06cc7a8ba"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Evaluating RMSE, MAE of algorithm KNNBasic on 5 split(s).\n",
            "\n",
            "                  Fold 1  Fold 2  Fold 3  Fold 4  Fold 5  Mean    Std     \n",
            "RMSE (testset)    0.9786  0.9798  0.9773  0.9737  0.9792  0.9777  0.0022  \n",
            "MAE (testset)     0.7745  0.7714  0.7717  0.7709  0.7717  0.7720  0.0013  \n",
            "Fit time          0.67    0.93    0.80    0.59    0.46    0.69    0.16    \n",
            "Test time         9.53    9.13    8.98    8.93    2.01    7.72    2.86    \n"
          ]
        },
        {
          "output_type": "execute_result",
          "data": {
            "text/plain": [
              "{'test_rmse': array([0.97858231, 0.97983991, 0.97732256, 0.97368035, 0.97921834]),\n",
              " 'test_mae': array([0.77451672, 0.77144476, 0.77165026, 0.77089565, 0.77170352]),\n",
              " 'fit_time': (0.6664748191833496,\n",
              "  0.9284124374389648,\n",
              "  0.8004293441772461,\n",
              "  0.5943918228149414,\n",
              "  0.45658111572265625),\n",
              " 'test_time': (9.527153730392456,\n",
              "  9.132725715637207,\n",
              "  8.978357076644897,\n",
              "  8.930379629135132,\n",
              "  2.012232542037964)}"
            ]
          },
          "metadata": {},
          "execution_count": 23
        }
      ],
      "source": [
        "model = KNNBasic()\n",
        "cross_validate(model,data,measures=['rmse','mae'],cv=5,n_jobs=4,verbose=True)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "QFEFPuSflHew"
      },
      "source": [
        "* SVD를 사용한 협업 필터링"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 24,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "H6HJ5bKOlHIb",
        "outputId": "112205b4-f197-4b63-8494-2d21cdb7b2a7"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Evaluating RMSE, MAE of algorithm SVD on 5 split(s).\n",
            "\n",
            "                  Fold 1  Fold 2  Fold 3  Fold 4  Fold 5  Mean    Std     \n",
            "RMSE (testset)    0.9387  0.9349  0.9364  0.9320  0.9348  0.9354  0.0022  \n",
            "MAE (testset)     0.7412  0.7349  0.7368  0.7374  0.7372  0.7375  0.0021  \n",
            "Fit time          2.51    2.40    2.82    2.64    1.20    2.31    0.57    \n",
            "Test time         0.45    0.46    0.28    0.33    0.21    0.34    0.10    \n"
          ]
        },
        {
          "output_type": "execute_result",
          "data": {
            "text/plain": [
              "{'test_rmse': array([0.93873374, 0.93486185, 0.936411  , 0.9320026 , 0.9348297 ]),\n",
              " 'test_mae': array([0.74123116, 0.7349203 , 0.73684566, 0.73737489, 0.73721972]),\n",
              " 'fit_time': (2.5072202682495117,\n",
              "  2.395383358001709,\n",
              "  2.817045211791992,\n",
              "  2.6439733505249023,\n",
              "  1.2039103507995605),\n",
              " 'test_time': (0.44979166984558105,\n",
              "  0.4582061767578125,\n",
              "  0.27826738357543945,\n",
              "  0.32677316665649414,\n",
              "  0.21005868911743164)}"
            ]
          },
          "metadata": {},
          "execution_count": 24
        }
      ],
      "source": [
        "model = SVD()\n",
        "cross_validate(model,data,measures=['rmse','mae'],cv=5,n_jobs=4,verbose=True)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "MqK8Xgeglkmj"
      },
      "source": [
        "* NMF를 사용한 협업 필터링"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 25,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "zSwGKHEDkyue",
        "outputId": "373c7813-3a77-4ea1-9ae4-070ae4c82c31"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Evaluating RMSE, MAE of algorithm NMF on 5 split(s).\n",
            "\n",
            "                  Fold 1  Fold 2  Fold 3  Fold 4  Fold 5  Mean    Std     \n",
            "RMSE (testset)    0.9578  0.9625  0.9686  0.9718  0.9590  0.9639  0.0054  \n",
            "MAE (testset)     0.7532  0.7569  0.7622  0.7635  0.7508  0.7573  0.0049  \n",
            "Fit time          3.93    3.77    3.77    2.98    0.84    3.06    1.16    \n",
            "Test time         0.38    0.39    0.26    0.40    0.10    0.31    0.11    \n"
          ]
        },
        {
          "output_type": "execute_result",
          "data": {
            "text/plain": [
              "{'test_rmse': array([0.95777145, 0.9625458 , 0.96861164, 0.9717725 , 0.9589732 ]),\n",
              " 'test_mae': array([0.75321831, 0.75692312, 0.76221036, 0.76354898, 0.75081854]),\n",
              " 'fit_time': (3.9284884929656982,\n",
              "  3.7662601470947266,\n",
              "  3.770768642425537,\n",
              "  2.9798078536987305,\n",
              "  0.8373351097106934),\n",
              " 'test_time': (0.37585020065307617,\n",
              "  0.3930232524871826,\n",
              "  0.2555837631225586,\n",
              "  0.40056633949279785,\n",
              "  0.10357213020324707)}"
            ]
          },
          "metadata": {},
          "execution_count": 25
        }
      ],
      "source": [
        "model = NMF()\n",
        "cross_validate(model,data,measures=['rmse','mae'],cv=5,n_jobs=4,verbose=True)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "odXxXkX0mi_7"
      },
      "source": [
        "* SVD++를 사용한 협업 필터링"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 26,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "Ck153w1Tlsxa",
        "outputId": "4f6a7507-cad5-4046-b71b-8c2073d05944"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Evaluating RMSE, MAE of algorithm SVDpp on 5 split(s).\n",
            "\n",
            "                  Fold 1  Fold 2  Fold 3  Fold 4  Fold 5  Mean    Std     \n",
            "RMSE (testset)    0.9106  0.9279  0.9153  0.9250  0.9156  0.9189  0.0065  \n",
            "MAE (testset)     0.7123  0.7294  0.7198  0.7260  0.7165  0.7208  0.0062  \n",
            "Fit time          76.20   75.41   76.31   77.43   20.88   65.25   22.19   \n",
            "Test time         10.83   11.21   10.54   10.39   2.50    9.09    3.31    \n"
          ]
        },
        {
          "output_type": "execute_result",
          "data": {
            "text/plain": [
              "{'test_rmse': array([0.91057206, 0.92788074, 0.91528913, 0.92496397, 0.91562684]),\n",
              " 'test_mae': array([0.71226827, 0.72937351, 0.71977352, 0.72598337, 0.71654675]),\n",
              " 'fit_time': (76.1953341960907,\n",
              "  75.41423511505127,\n",
              "  76.30955958366394,\n",
              "  77.42996025085449,\n",
              "  20.88268208503723),\n",
              " 'test_time': (10.828246116638184,\n",
              "  11.212045669555664,\n",
              "  10.542290687561035,\n",
              "  10.385873079299927,\n",
              "  2.4980673789978027)}"
            ]
          },
          "metadata": {},
          "execution_count": 26
        }
      ],
      "source": [
        "model = SVDpp()\n",
        "cross_validate(model,data,measures=['rmse','mae'],cv=5,n_jobs=4,verbose=True)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "hMNwOXpjqeWq"
      },
      "source": [
        "## 하이브리드(Hybrid)\n",
        "\n",
        "* 컨텐츠 기반 필터링과 협업 필터링을 조합한 방식\n",
        "* 많은 하이브리드 방식이 존재\n",
        "* 실습에서는 협업 필터링으로 임베딩을 학습하고 컨텐츠 기반 필터링으로 유사도 기반 추천을 수행하는 추천 엔진 개발"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 27,
      "metadata": {
        "id": "9mDHmnwFmzwd"
      },
      "outputs": [],
      "source": [
        "import numpy as np\n",
        "from sklearn.decomposition import randomized_svd,non_negative_factorization\n",
        "from surprise import Dataset"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 28,
      "metadata": {
        "id": "MtEuyQGGMmor"
      },
      "outputs": [],
      "source": [
        "data=Dataset.load_builtin('ml-100k',prompt=False)\n",
        "raw_data = np.array(data.raw_ratings,dtype=int)\n",
        "raw_data[:,0] -=1\n",
        "raw_data[:,1] -=1"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 29,
      "metadata": {
        "id": "esDSrjm_NshD",
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "outputId": "27dd8dc9-537e-4146-ab7e-96f77877c16a"
      },
      "outputs": [
        {
          "output_type": "execute_result",
          "data": {
            "text/plain": [
              "(943, 1682)"
            ]
          },
          "metadata": {},
          "execution_count": 29
        }
      ],
      "source": [
        "n_users = np.max(raw_data[:,0])\n",
        "n_movies=np.max(raw_data[:,1])\n",
        "shap = (n_users+1,n_movies + 1)\n",
        "shap"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 30,
      "metadata": {
        "id": "v6lc4h2sNY_7"
      },
      "outputs": [],
      "source": [
        "adj_matrix = np.ndarray(shape,dtype=int)\n",
        "for user_id,movie_id,rating,time in raw_data:\n",
        "  adj_matrix[user_id][movie_id] = rating"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 31,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "bZnx294OTntk",
        "outputId": "bfb384f3-e255-4ddb-f52c-acebae948a63"
      },
      "outputs": [
        {
          "output_type": "execute_result",
          "data": {
            "text/plain": [
              "array([[5, 3, 4, ..., 0, 0, 0],\n",
              "       [4, 0, 0, ..., 0, 0, 0],\n",
              "       [0, 0, 0, ..., 0, 0, 0],\n",
              "       ...,\n",
              "       [5, 0, 0, ..., 0, 0, 0],\n",
              "       [0, 0, 0, ..., 0, 0, 0],\n",
              "       [0, 5, 0, ..., 0, 0, 0]])"
            ]
          },
          "metadata": {},
          "execution_count": 31
        }
      ],
      "source": [
        "adj_matrix"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 32,
      "metadata": {
        "id": "mpw7bmE-SVon"
      },
      "outputs": [],
      "source": [
        "U,S,V=randomized_svd(adj_matrix,n_components=2)\n",
        "S = np.diag(S)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 33,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "sdnXxd6lODFy",
        "outputId": "bfe9e1d5-faf4-4812-bdd1-0f72971aa80f"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "(943, 2)\n",
            "(2, 2)\n",
            "(2, 1682)\n"
          ]
        }
      ],
      "source": [
        "print(U.shape)\n",
        "print(S.shape)\n",
        "print(V.shape)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 34,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "zBvnhmuhOxDx",
        "outputId": "7d58884d-ea1d-4959-a43d-7dabb24f0c1c"
      },
      "outputs": [
        {
          "output_type": "execute_result",
          "data": {
            "text/plain": [
              "array([[ 3.91732666e+00,  1.47276645e+00,  7.98262053e-01, ...,\n",
              "         6.24907562e-04,  1.41100868e-02,  1.36545903e-02],\n",
              "       [ 1.85777227e+00,  3.96191086e-01,  5.05705315e-01, ...,\n",
              "         5.38862817e-03,  1.77236577e-03,  5.26947910e-04],\n",
              "       [ 8.94989150e-01,  1.71578418e-01,  2.51738327e-01, ...,\n",
              "         2.92094643e-03,  5.39930275e-04, -1.25743976e-04],\n",
              "       ...,\n",
              "       [ 9.92051664e-01,  2.10814886e-01,  2.70363040e-01, ...,\n",
              "         2.89019059e-03,  9.34215147e-04,  2.66602053e-04],\n",
              "       [ 1.30425382e+00,  5.27669942e-01,  2.50080177e-01, ...,\n",
              "        -4.20678447e-04,  5.30525938e-03,  5.28070342e-03],\n",
              "       [ 2.82999402e+00,  9.70812230e-01,  6.15871609e-01, ...,\n",
              "         2.02091477e-03,  8.67740494e-03,  8.03107408e-03]])"
            ]
          },
          "metadata": {},
          "execution_count": 34
        }
      ],
      "source": [
        "np.matmul(np.matmul(U,S),V)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "3pSBMfF7d74E"
      },
      "source": [
        "* 사용자 기반 추천\n",
        "* 나와 비슷한 취향을 가진 다른 사용자의 행동을 추천\n",
        "* 사용자 특징 벡터의 유사도 사용"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 35,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "N6nYexy6cq9V",
        "outputId": "6ef1fbb5-f387-441e-c8a1-f1abfb49a293"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Bset Match: 0.9999942292116542, Best Match ID:235\n"
          ]
        }
      ],
      "source": [
        "my_id, my_vector = 0, U[0]\n",
        "best_match, best_match_id, best_match_vector = -1,-1,[]\n",
        "\n",
        "for user_id, user_vector in enumerate(U):\n",
        "  if my_id !=user_id:\n",
        "    cos_similarity = compute_cos_similarity(my_vector, user_vector)\n",
        "    if cos_similarity > best_match:\n",
        "      best_match = cos_similarity\n",
        "      best_match_id = user_id\n",
        "      best_match_vector = user_vector\n",
        "\n",
        "\n",
        "print('Bset Match: {}, Best Match ID:{}'.format(best_match,best_match_id))"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 35,
      "metadata": {
        "id": "wdISUAEIfoHi"
      },
      "outputs": [],
      "source": []
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "0nSD2izbhJix"
      },
      "source": [
        "* 항목 기반 추천\n",
        "* 내가 본 항목과 비슷한 항목을 추천\n",
        "* 항목 특징 벡터의 유사도 사용"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 35
        },
        "id": "vCLxtkLdgM-s",
        "outputId": "3e8ddd9c-91a7-4e90-84f6-1b7ac81c334a"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "Best Match: 0.9999999951364141, Best Match ID: 1287\n"
          ]
        }
      ],
      "source": []
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 55
        },
        "id": "IZ49Abk7iBeU",
        "outputId": "c72abba8-b668-4226-8f96-102615544e71"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "[0, 1, 4, 5, 9, 12, 14, 15, 16, 17, 19, 20, 22, 24, 25, 37, 40, 41, 42, 43, 44, 48, 53, 55, 56, 57, 58, 61, 62, 63, 64, 65, 66, 69, 71, 72, 74, 76, 78, 80, 81, 82, 83, 88, 91, 92, 93, 94, 95, 96, 98, 100, 101, 105, 107, 108, 116, 119, 120, 123, 124, 127, 129, 130, 133, 136, 137, 140, 143, 144, 147, 149, 150, 156, 157, 159, 161, 167, 173, 176, 177, 180, 181, 183, 188, 192, 193, 197, 198, 199, 200, 201, 202, 203, 208, 209, 212, 215, 221, 222, 229, 230, 231, 233, 234, 241, 242, 243, 245, 246, 247, 248, 249, 250, 251, 252, 253, 255, 261, 262, 264, 267, 270, 273, 274, 275, 276, 278, 279, 285, 286, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 300, 302, 304, 306, 307, 310, 311, 312, 313, 319, 321, 323, 324, 325, 326, 329, 330, 331, 335, 337, 338, 339, 342, 343, 344, 346, 347, 349, 356, 358, 359, 362, 364, 370, 373, 377, 378, 379, 380, 386, 387, 388, 389, 392, 393, 394, 395, 397, 398, 400, 401, 402, 405, 406, 410, 411, 415, 416, 418, 421, 423, 424, 428, 431, 433, 434, 437, 440, 444, 446, 449, 453, 454, 455, 456, 457, 458, 459, 462, 464, 466, 467, 469, 470, 471, 477, 478, 482, 483, 485, 486, 487, 489, 492, 493, 494, 496, 499, 502, 504, 507, 511, 513, 516, 517, 520, 522, 524, 525, 531, 532, 533, 534, 535, 536, 539, 540, 541, 544, 547, 548, 549, 551, 552, 553, 559, 560, 561, 566, 568, 575, 576, 578, 579, 581, 587, 591, 592, 596, 598, 601, 604, 605, 608, 609, 611, 612, 613, 617, 619, 620, 621, 623, 629, 631, 633, 634, 635, 636, 641, 642, 647, 648, 649, 652, 653, 654, 656, 657, 659, 660, 662, 663, 664, 668, 673, 675, 676, 677, 678, 679, 681, 683, 688, 689, 690, 691, 696, 697, 698, 700, 702, 704, 705, 707, 708, 709, 713, 714, 715, 720, 722, 725, 726, 729, 730, 732, 734, 737, 741, 743, 744, 745, 746, 747, 748, 750, 755, 756, 758, 760, 762, 763, 766, 767, 768, 769, 770, 772, 776, 778, 784, 785, 787, 788, 789, 791, 792, 793, 794, 795, 797, 799, 803, 804, 805, 806, 814, 816, 820, 821, 822, 825, 828, 829, 830, 834, 837, 838, 842, 846, 851, 853, 863, 864, 866, 867, 869, 871, 878, 879, 880, 881, 882, 884, 885, 886, 888, 889, 891, 892, 893, 894, 895, 896, 898, 900, 901, 902, 906, 909, 912, 915, 916, 917, 918, 920, 921, 922, 923, 926, 928, 929, 931, 932, 933, 934, 935, 937, 940]\n"
          ]
        }
      ],
      "source": []
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "7uAlUROxj2nA"
      },
      "source": [
        "* 비음수 행렬 분해를 사용한 하이브리드 추천"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 145
        },
        "id": "Ou2UGuXMTY39",
        "outputId": "dabd8748-bf4e-4fa2-ebfd-f36ae59cb386"
      },
      "outputs": [
        {
          "data": {
            "text/plain": [
              "array([[5, 3, 4, ..., 0, 0, 0],\n",
              "       [4, 0, 0, ..., 0, 0, 0],\n",
              "       [0, 0, 0, ..., 0, 0, 0],\n",
              "       ...,\n",
              "       [5, 0, 0, ..., 0, 0, 0],\n",
              "       [0, 0, 0, ..., 0, 0, 0],\n",
              "       [0, 5, 0, ..., 0, 0, 0]])"
            ]
          },
          "execution_count": 51,
          "metadata": {
            "tags": []
          },
          "output_type": "execute_result"
        }
      ],
      "source": []
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 74
        },
        "id": "yThSdQxDjnsk",
        "outputId": "444aa1f9-65ab-449b-8e2c-274d603a5cff"
      },
      "outputs": [
        {
          "name": "stderr",
          "output_type": "stream",
          "text": [
            "/usr/local/lib/python3.6/dist-packages/sklearn/decomposition/_nmf.py:1035: FutureWarning: The default value of init will change from random to None in 0.23 to make it consistent with decomposition.NMF.\n",
            "  \"with decomposition.NMF.\", FutureWarning)\n"
          ]
        }
      ],
      "source": []
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 254
        },
        "id": "hqtcd6HmkOsA",
        "outputId": "022d88e1-a42a-454f-80f1-209a8ce31ffa"
      },
      "outputs": [
        {
          "data": {
            "text/plain": [
              "array([[3.71104386e+00, 1.48478414e+00, 7.39554801e-01, ...,\n",
              "        3.64526020e-03, 1.45529217e-02, 1.44127541e-02],\n",
              "       [2.11740926e+00, 2.36733594e-01, 5.51609827e-01, ...,\n",
              "        4.76715033e-03, 2.44095997e-05, 0.00000000e+00],\n",
              "       [9.85437620e-01, 1.10175294e-01, 2.56718002e-01, ...,\n",
              "        2.21862129e-03, 1.13601741e-05, 0.00000000e+00],\n",
              "       ...,\n",
              "       [1.04462665e+00, 1.16792830e-01, 2.72137435e-01, ...,\n",
              "        2.35187989e-03, 1.20425082e-05, 0.00000000e+00],\n",
              "       [1.45791701e+00, 5.42098835e-01, 2.99293177e-01, ...,\n",
              "        1.61349670e-03, 5.15831117e-03, 5.10699643e-03],\n",
              "       [2.44660591e+00, 9.41428352e-01, 4.95526147e-01, ...,\n",
              "        2.56812371e-03, 9.08641597e-03, 8.99741614e-03]])"
            ]
          },
          "execution_count": 53,
          "metadata": {
            "tags": []
          },
          "output_type": "execute_result"
        }
      ],
      "source": []
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "6DGX9EtEop4i"
      },
      "source": [
        "* 사용자 기반 추천"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 35
        },
        "id": "dndXY3Gvm7zs",
        "outputId": "b0e6157c-dffe-47f2-e0e8-045a6d207f7b"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "Best Match: 0.99999996802728, Best Match ID: 166\n"
          ]
        }
      ],
      "source": [
        "my_id, my_vector = 0, U[0]  # 내 id가 0번 이라고 가정\n",
        "b"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 55
        },
        "id": "njszNHE_m9MK",
        "outputId": "d70f8e65-8d77-4215-b5e5-4f5b79994b0f"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "[287, 289, 317, 363, 380, 391, 403, 434, 464, 477, 485, 492, 511, 512, 520, 529, 553, 567, 602, 605, 614, 640, 654, 658, 672, 673, 674, 697, 718, 725, 732, 734, 830, 948, 1124, 1125, 1146, 1199, 1224, 1303, 1304, 1305, 1306, 1307, 1308, 1309]\n"
          ]
        }
      ],
      "source": [
        "recommend_list = []\n",
        "for i, log in enumerate(zip(adj_matrix[my_id], adj_matrix[best_match_id])):\n",
        "  log1, log2 = log\n",
        "  if log1 < 1. and log2 > 0.:\n",
        "    recommend_list.append(i)\n",
        "print(recommend_list)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "F21eqO8dosUE"
      },
      "source": [
        "* 항목 기반 추천"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 35
        },
        "id": "G8RZo0Mvom4X",
        "outputId": "bac513b3-0c73-454f-e276-c4827c36914f"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "Best Match: 0.9999999346987367, Best Match ID: 497\n"
          ]
        }
      ],
      "source": [
        "my_id, my_vector = 0, B.T[0]  # 기준 항목이 0번 이라고 가정\n",
        "best_match, best_match_id, best_match_vector = -1, -1, []\n",
        "\n",
        "for item_id, item_vector in enumerate(V.T):\n",
        "  if my_id != item_id:\n",
        "    cos_similarity = compute_cos_similarity(my_vector, item_vector)\n",
        "    if cos_similarity > best_match:\n",
        "      best_match = cos_similarity\n",
        "      best_match_id = item_id\n",
        "      best_match_vector = item_vector\n",
        "\n",
        "print('Best Match: {}, Best Match ID: {}'.format(best_match, best_match_id))"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 55
        },
        "id": "G_ua-2Lcox8i",
        "outputId": "a1d953df-dd09-4563-f522-8bb9fce8244a"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "[0, 1, 4, 5, 9, 12, 14, 15, 16, 17, 19, 20, 22, 24, 25, 37, 40, 41, 42, 43, 44, 48, 53, 55, 56, 57, 58, 61, 62, 63, 64, 65, 66, 69, 71, 72, 74, 76, 78, 80, 81, 82, 83, 88, 91, 92, 93, 94, 95, 96, 98, 100, 101, 105, 107, 108, 116, 119, 120, 123, 124, 127, 129, 130, 133, 136, 137, 140, 143, 144, 147, 149, 150, 156, 157, 159, 161, 167, 173, 176, 177, 180, 181, 183, 188, 192, 193, 197, 198, 199, 200, 201, 202, 203, 208, 209, 212, 215, 221, 222, 229, 230, 231, 233, 234, 241, 242, 243, 245, 246, 247, 248, 249, 250, 251, 252, 253, 255, 261, 262, 264, 267, 270, 273, 274, 275, 276, 278, 279, 285, 286, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 300, 302, 304, 306, 307, 310, 311, 312, 313, 319, 321, 323, 324, 325, 326, 329, 330, 331, 335, 337, 338, 339, 342, 343, 344, 346, 347, 349, 356, 358, 359, 362, 364, 370, 373, 377, 378, 379, 380, 386, 387, 388, 389, 392, 393, 394, 395, 397, 398, 400, 401, 402, 405, 406, 410, 411, 415, 416, 418, 421, 423, 424, 428, 431, 433, 434, 437, 440, 444, 446, 449, 453, 454, 455, 456, 457, 458, 459, 462, 464, 466, 467, 469, 470, 471, 477, 478, 482, 483, 485, 486, 487, 489, 492, 493, 494, 496, 499, 502, 504, 507, 511, 513, 516, 517, 520, 522, 524, 525, 531, 532, 533, 534, 535, 536, 539, 540, 541, 544, 547, 548, 549, 551, 552, 553, 559, 560, 561, 566, 568, 575, 576, 578, 579, 581, 587, 591, 592, 596, 598, 601, 604, 605, 608, 609, 611, 612, 613, 617, 619, 620, 621, 623, 629, 631, 633, 634, 635, 636, 641, 642, 647, 648, 649, 652, 653, 654, 656, 657, 659, 660, 662, 663, 664, 668, 673, 675, 676, 677, 678, 679, 681, 683, 688, 689, 690, 691, 696, 697, 698, 700, 702, 704, 705, 707, 708, 709, 713, 714, 715, 720, 722, 725, 726, 729, 730, 732, 734, 737, 741, 743, 744, 745, 746, 747, 748, 750, 755, 756, 758, 760, 762, 763, 766, 767, 768, 769, 770, 772, 776, 778, 784, 785, 787, 788, 789, 791, 792, 793, 794, 795, 797, 799, 803, 804, 805, 806, 814, 816, 820, 821, 822, 825, 828, 829, 830, 834, 837, 838, 842, 846, 851, 853, 863, 864, 866, 867, 869, 871, 878, 879, 880, 881, 882, 884, 885, 886, 888, 889, 891, 892, 893, 894, 895, 896, 898, 900, 901, 902, 906, 909, 912, 915, 916, 917, 918, 920, 921, 922, 923, 926, 928, 929, 931, 932, 933, 934, 935, 937, 940]\n"
          ]
        }
      ],
      "source": [
        "recommend_list = []\n",
        "for i, user_vector in enumerate(adj_matrix):\n",
        "  if adj_matrix[i][my_id] > 0.9:\n",
        "    recommend_list.append(i)\n",
        "print(recommend_list)"
      ]
    }
  ],
  "metadata": {
    "accelerator": "GPU",
    "colab": {
      "provenance": [],
      "include_colab_link": true
    },
    "gpuClass": "standard",
    "kernelspec": {
      "display_name": "Python 3",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}